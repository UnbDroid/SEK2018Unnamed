/*
  Arquivo: filesIO.nxc
  Descricao: Este arquivo contem as definicoes para criacao,
             leitura e escrita de arquivos.
  Autores: Renato Nobre
  Data de Modificacao: 06/09/2018
  Versao: 1.0
*/


#include "include/filesIO.h"

void initConfig(config &c, int id, float value) {
  c.id = id;
  c.value = value;
}

void logError(const unsigned int code) {
   TextOut(0, LCD_LINE2, "code            ");
   TextOut(50, LCD_LINE2, FormatNum("%04x", code));
}

int checkFileExistence(string fileName, unsigned int fileSize) {
  unsigned int rtn_code = CreateFile(fileName, fileSize, handle);
  CloseFile(handle);
  if (rtn_code == LDR_FILEEXISTS) {
    return 1;
  } else {
    return 0;
  }


}

void deleteFile(string fileName, unsigned int fileSize) {
  if (checkFileExistence(fileName, fileSize) == 1) {
    unsigned int rtn_code = DeleteFile(fileName);
  }
}

void openForWrite(string fileName, unsigned int fileSize) {
  handle = 0;

  // Start with the assumptions the file doesn't exist and needs to be created.
  unsigned int rtn_code = CreateFile(fileName, fileSize, handle);

  // If the file already exists, open it with the intent of adding to the data
  // that is already there.
  if (rtn_code == LDR_FILEEXISTS) {
    rtn_code = OpenFileAppend(fileName, fileSize, handle);
  }
  // Return code handling
  switch (rtn_code) {
    case LDR_SUCCESS:
       return;
    case LDR_FILEISFULL:
       TextOut(0, LCD_LINE1, "file is full    ");
       break;
    default:
       // Unanticipated exception.
       TextOut(0, LCD_LINE1, "write open      ");
       logError(rtn_code);
       break;
  }
}

void openForRead(string fileName, unsigned int fileSize) {
  unsigned int file_size = fileSize;
  handle = 0;
  unsigned int rtn_code = OpenFileRead(fileName, fileSize, handle);
  // Return code handling
  if (rtn_code != LDR_SUCCESS) {
     // Unanticipated exception.
     TextOut(0, LCD_LINE1, "read open       ");
     logError(rtn_code);
  }
}

void writeConfigOnFile(const config recd) {
  unsigned int rtn_code = Write(handle, recd);

  // Return code handling
  if (rtn_code != LDR_SUCCESS) {
     switch (rtn_code) {
       case LDR_EOFEXPECTED:
          TextOut(0, LCD_LINE1, "no more space   ");
          break;
       default:
          // Unanticipated exception.
          TextOut(0, LCD_LINE1, "write failed    ");
          logError(rtn_code);
          break;
     }
  }
}

void readConfigFile(config &reacd) {
  while (true) {
     unsigned int rtn_code = Read(handle, reacd);
     // Return code handling
     switch (rtn_code) {
       case LDR_SUCCESS:

          ClearScreen();
          // Record has been read. Display circle described by it.
          NumOut(0,LCD_LINE1,reacd.id);
          NumOut(0,LCD_LINE3,reacd.value);

          Wait(SEC_2);
          break;
       case LDR_ENDOFFILE:
          // No more data to read.
          return;
       default:
          // Unanticipated exception.
          TextOut(0, LCD_LINE1, "read failed     ");
          logError(rtn_code);
     }
  }
}
