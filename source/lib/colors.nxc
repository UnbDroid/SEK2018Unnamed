/*
  Arquivo: colors.nxc
  Descricao: Este arquivo contem as definicoes da
    biblioteca de identificacao de cor.
  Autores: Renato Nobre
  Data de Modificacao: 13/09/2018
  Versao: 1.0
*/

#include "include/colors.h"


string getColorName(int color){
  string colorName;

  switch (color) {
    case ID_AMARELO:
      colorName = "AMARELO";
      break;
    case ID_VERDE:
      colorName = "VERDE";
      break;
    case ID_AZUL:
      colorName = "AZUL";
      break;
    case ID_VERMELHO:
      colorName = "VERMELHO";
      break;
    case ID_PRETO:
      colorName = "PRETO";
      break;
    case ID_BRANCO:
      colorName = "BRANCO";
      break;
    case ID_QUEDA:
      colorName = "QUEDA";
      break;
    default:
      colorName = "ERRO IDENT";
      break;
  }

  return colorName;
}

int intervalValue(int value) {
    int regionIndex = 0;
    regionIndex = (value/INTERVAL_SIZE);
    return regionIndex;
}

int intervalError(int value, int sum){
  if (sum == SUB) {
    return (value-MEAN_ERROR)/INTERVAL_SIZE;
  } else {
    return (value+MEAN_ERROR)/INTERVAL_SIZE;
  }
}

void calculateInterval(int r, int g, int b, int w) {
  int intervalR, intervalG, intervalB, intervalW;
  int intervalRPlus, intervalGPlus, intervalBPlus, intervalWPlus;
  int intervalRMinor, intervalGMinor, intervalBMinor, intervalWMinor;

  intervalR = intervalValue(r);
  intervalG = intervalValue(g);
  intervalB = intervalValue(b);
  intervalW = intervalValue(w);

  intervalRPlus = intervalError(r, SUM);
  intervalGPlus = intervalError(g, SUM);
  intervalBPlus = intervalError(b, SUM);
  intervalWPlus = intervalError(w, SUM);

  intervalRMinor = intervalError(r, SUB);
  intervalGMinor = intervalError(g, SUB);
  intervalBMinor = intervalError(b, SUB);
  intervalWMinor = intervalError(w, SUB);

  colorsMat[0][0] = intervalR;
  colorsMat[0][1] = intervalRPlus;
  colorsMat[0][2] = intervalRMinor;
  colorsMat[1][0] = intervalG;
  colorsMat[1][1] = intervalGPlus;
  colorsMat[1][2] = intervalGMinor;
  colorsMat[2][0] = intervalB;
  colorsMat[2][1] = intervalBPlus;
  colorsMat[2][2] = intervalBMinor;
  colorsMat[3][0] = intervalW;
  colorsMat[3][1] = intervalWPlus;
  colorsMat[3][2] = intervalWMinor;
}

int evalIntervalAmount(int value[], int expectedInterval) {
  int amount = 0;
  if (value[0] == expectedInterval){
    amount += 1;
  }
  if (value[1] == expectedInterval){
    amount += 1;
  }
  if (value[2] == expectedInterval){
    amount += 1;
  }
  return amount;
}

int evalInterval(int value[], int expectedInterval) {
  if ((value[0] == expectedInterval)||(value[1] == expectedInterval)||(value[2] == expectedInterval)) {
    return 1;
  } else {
    return 0;
  }
}

int howManyColor(int intervalR, int intervalG, int intervalB, int intervalW) {
  int total;
  int r[3];
  r[0] = colorsMat[0][0];
  r[1] = colorsMat[0][1];
  r[2] = colorsMat[0][2];
  int g[3];
  g[0] = colorsMat[1][0];
  g[1] = colorsMat[1][1];
  g[2] = colorsMat[1][2];
  int b[3];
  b[0] = colorsMat[2][0];
  b[1] = colorsMat[2][1];
  b[2] = colorsMat[2][2];
  int w[3];
  w[0] = colorsMat[3][0];
  w[1] = colorsMat[3][1];
  w[2] = colorsMat[3][2];

  total = evalIntervalAmount(b, intervalB) + evalIntervalAmount(w, intervalW) + evalIntervalAmount(r, intervalR) +
  evalIntervalAmount(g, intervalG);

  return total;
}

int isItColor(int intervalR, int intervalG, int intervalB, int intervalW) {

  int r[3];
  r[0] = colorsMat[0][0];
  r[1] = colorsMat[0][1];
  r[2] = colorsMat[0][2];
  int g[3];
  g[0] = colorsMat[1][0];
  g[1] = colorsMat[1][1];
  g[2] = colorsMat[1][2];
  int b[3];
  b[0] = colorsMat[2][0];
  b[1] = colorsMat[2][1];
  b[2] = colorsMat[2][2];
  int w[3];
  w[0] = colorsMat[3][0];
  w[1] = colorsMat[3][1];
  w[2] = colorsMat[3][2];

  if ((evalInterval(r, intervalR) == 1) &&
     (evalInterval(g, intervalG) == 1) &&
     (evalInterval(b, intervalB) == 1) &&
     (evalInterval(w, intervalW) == 1)) {
       return 1;
  } else {
    return 0;
  }
}

int leftSensorColorRead(ColorConf &defColors[]){
  int color = -1;
  byte r = 0, g = 0, b=0, w=0, num=0;
  int redAm, greenAm, blueAm, whiteAm, yellowAm, blackAm, fallAm;
  ReadSensorHTColor2Active(COLOR_LEFT, num, r, g, b, w);


  calculateInterval(r, g, b, w);

  greenAm = howManyColor(defColors[0].leftRInterval,
                defColors[0].leftGInterval,
                defColors[0].leftBInterval,
                defColors[0].leftWInterval);

  blueAm = howManyColor(defColors[1].leftRInterval,
                defColors[1].leftGInterval,
                defColors[1].leftBInterval,
                defColors[1].leftWInterval);

  redAm = howManyColor(defColors[2].leftRInterval,
                defColors[2].leftGInterval,
                defColors[2].leftBInterval,
                defColors[2].leftWInterval);

  blackAm = howManyColor(defColors[3].leftRInterval,
                defColors[3].leftGInterval,
                defColors[3].leftBInterval,
                defColors[3].leftWInterval);

  whiteAm = howManyColor(defColors[4].leftRInterval,
                defColors[4].leftGInterval,
                defColors[4].leftBInterval,
                defColors[4].leftWInterval);

  fallAm = howManyColor(defColors[5].leftRInterval,
                defColors[5].leftGInterval,
                defColors[5].leftBInterval,
                defColors[5].leftWInterval);

  yellowAm = howManyColor(defColors[6].leftRInterval,
                defColors[6].leftGInterval,
                defColors[6].leftBInterval,
                defColors[6].leftWInterval);

  int b1, b2, b3, b4;
  int c1, c2, c3, c4;

  b4 = yellowAm;

  if (greenAm > blueAm) {
    b1 = greenAm;
    c1 = ID_VERDE;
  } else {
    b1 = blueAm;
    c1 = ID_AZUL;
  }

  if (redAm > blackAm) {
    b2 = redAm;
    c2 = ID_VERMELHO;
  } else {
    b2 = blackAm;
    c2 = ID_PRETO;
  }

  if (whiteAm > fallAm) {
    b3 = whiteAm;
    c3 = ID_BRANCO;
  } else {
    b3 = fallAm;
    c3 = ID_QUEDA;
  }

  if (b1 > b2) {
    b1 = b1;
    c1 = c1;
  } else {
    b1 = b2;
    c1 = c2;
  }

  if (b3 > b4) {
    b3 = b3;
    c3 = c3;
  } else {
    b3 = b4;
    c3 = c4;
  }

  if (b1 > b3) {
    color = c1;
  } else {
    color = c3;
  }

  return color;
}


int leftSensorColor(ColorConf &defColors[]){
  int left = leftSensorColorRead(defColors);
  int newLeft, leftAmmount;

  leftAmmount = 0;
  for(int i = 0; i < 1; i ++){
    newLeft = leftSensorColorRead(defColors);
    if (newLeft == left){
      leftAmmount += 1;
    }
  }

  if (leftAmmount == 1) {
    return newLeft;
  }
  return ID_ERRO;
}

int rightSensorColor(ColorConf &defColors[]){
  int right = rightSensorColorRead(defColors);
  int newRight, rightAmmount;

  rightAmmount = 0;
  for(int i = 0; i < 1; i ++){
    newRight = rightSensorColorRead(defColors);
    if (newRight == right){
      rightAmmount += 1;
    }
  }

  if (rightAmmount == 1) {
    return newRight;
  }

  return ID_ERRO;
}

int rightSensorColorRead(ColorConf &defColors[]){
  int color = ID_ERRO;
  byte r = 0, g = 0, b=0, w=0, num=0;
  int redAm, greenAm, blueAm, whiteAm, yellowAm, blackAm, fallAm;

  ReadSensorHTColor2Active(COLOR_RIGHT, num, r, g, b, w);

  calculateInterval(r, g, b, w);

  greenAm = howManyColor(defColors[0].rightRInterval,
                defColors[0].rightGInterval,
                defColors[0].rightBInterval,
                defColors[0].rightWInterval);

  blueAm = howManyColor(defColors[1].rightRInterval,
                defColors[1].rightGInterval,
                defColors[1].rightBInterval,
                defColors[1].rightWInterval);

  redAm = howManyColor(defColors[2].rightRInterval,
                defColors[2].rightGInterval,
                defColors[2].rightBInterval,
                defColors[2].rightWInterval);

  blackAm = howManyColor(defColors[3].rightRInterval,
                defColors[3].rightGInterval,
                defColors[3].rightBInterval,
                defColors[3].rightWInterval);

  whiteAm = howManyColor(defColors[4].rightRInterval,
                defColors[4].rightGInterval,
                defColors[4].rightBInterval,
                defColors[4].rightWInterval);

  fallAm = howManyColor(defColors[5].rightRInterval,
                defColors[5].rightGInterval,
                defColors[5].rightBInterval,
                defColors[5].rightWInterval);

  yellowAm = howManyColor(defColors[6].rightRInterval,
                defColors[6].rightGInterval,
                defColors[6].rightBInterval,
                defColors[6].rightWInterval);

  int b1, b2, b3, b4;
  int c1, c2, c3, c4;

  b4 = yellowAm;

  if (greenAm > blueAm) {
    b1 = greenAm;
    c1 = ID_VERDE;
  } else {
    b1 = blueAm;
    c1 = ID_AZUL;
  }

  if (redAm > blackAm) {
    b2 = redAm;
    c2 = ID_VERMELHO;
  } else {
    b2 = blackAm;
    c2 = ID_PRETO;
  }

  if (whiteAm > fallAm) {
    b3 = whiteAm;
    c3 = ID_BRANCO;
  } else {
    b3 = fallAm;
    c3 = ID_QUEDA;
  }

  if (b1 > b2) {
    b1 = b1;
    c1 = c1;
  } else {
    b1 = b2;
    c1 = c2;
  }

  if (b3 > b4) {
    b3 = b3;
    c3 = c3;
  } else {
    b3 = b4;
    c3 = c4;
  }

  if (b1 > b3) {
    color = c1;
  } else {
    color = c3;
  }

  return color;
}
