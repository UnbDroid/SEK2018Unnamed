/*
  Arquivo: route.nxc
  Descricao: Este programa cotem toda a logica de programacao do percorrimento de percurso
  Autores: Renato Nobre, Valesca Soares
  Data de Modificacao: 14/10/2018
  Versao: 0.3
*/
#include "include/route.h"

typedef struct {
  int front;
  int left;
  int right;
}Directions;

int currentColor;
int lastColor = -1;
int turnCount = 0;

Directions dir;

void init_dir(Directions &dir){
  dir.front = -1;
  dir.left = -1;
  dir.right = -1;
}

void recenter(ColorConf &defColors[]){
  if ((leftSensorColorRead(defColors) == ID_QUEDA) &&
      (rightSensorColorRead(defColors) == ID_QUEDA)) {
    Off(MOTOR_BOTH);
  } else if (leftSensorColorRead(defColors) == ID_QUEDA) {
    while (leftSensorColorRead(defColors) != ID_BRANCO) {
      OnRev(MOTOR_RIGHT, 40);
    }
  } else if (rightSensorColorRead(defColors) == ID_QUEDA){
    while (rightSensorColorRead(defColors) != ID_BRANCO) {
      OnRev(MOTOR_LEFT, 40);
    }
  }
}

int avoidFall(ColorConf &defColors[]){
  if ((leftSensorColorRead(defColors) == ID_QUEDA) ||
      (rightSensorColorRead(defColors) == ID_QUEDA)){
    Off(MOTOR_BOTH);
    recenter(defColors);
    Off(MOTOR_BOTH);
    return TRUE;
  }
  return FALSE;
}

void adjustPosition(ColorConf &defColors[], int idColor) {
  Off(MOTOR_BOTH);
  if (leftSensorColorRead(defColors) == idColor){
    while(rightSensorColorRead(defColors) != idColor) {
      OnFwd(MOTOR_RIGHT, 40);
    }
  } else if (rightSensorColorRead(defColors) == idColor){
    while(leftSensorColorRead(defColors) != idColor) {
      OnFwd(MOTOR_LEFT, 40);
    }
  }
  Off(MOTOR_BOTH);
}

int trackPosControll(ColorConf &defColors[], int idColor) {
  int leftColor, rightColor;
  leftColor = leftSensorColorRead(defColors);
  rightColor = rightSensorColorRead(defColors);
  if (avoidFall(defColors) == FALSE){
    if (leftColor != idColor){
      adjustPosition(defColors, leftColor);
    } else if (rightColor != idColor) {
      adjustPosition(defColors, rightColor);
    }
    return leftColor;
  } else {
    return ID_QUEDA;
  }
}

void moveUntilNotColor(ColorConf &defColors[], int idCor) {
  int leftColor, rightColor;
  leftColor = leftSensorColorRead(defColors);
  rightColor = rightSensorColorRead(defColors);
  start fowardPID;
  while ((leftColor == idCor) &&
       (rightColor == idCor)) {
   leftColor = leftSensorColorRead(defColors);
   rightColor = rightSensorColorRead(defColors);
  }
  stop fowardPID;
  Off(MOTOR_BOTH);
}

void centerOnIntersec() {
  fowardCm(19);
}

void evaluateDirection(int color) {
  currentColor = color;
  if ((currentColor != ID_PRETO)&&(lastColor != -1)) {
    if ((turnCount == 1)&&(dir.right == -1)){
      PlayTone(500, 500);
        dir.right = lastColor;
    } else if ((turnCount == 2)&&(dir.front == -1)){
        PlayTone(500, 500);
        dir.front = lastColor;
    } else if ((turnCount == 3)&&(dir.left == -1)) {
        PlayTone(500, 500);
        dir.left = lastColor;
    }
  }
  lastColor = currentColor;
}

void startRoute(ColorConf &defColors[]) {
  init_dir(dir);
  while(true){
    route(defColors);
  }
}

void route(ColorConf &defColors[]) {
  int color;
  moveUntilNotColor(defColors, ID_BRANCO);
  color = trackPosControll(defColors, ID_BRANCO);
  evaluateDirection(color);
  if (color == ID_PRETO) {
      make180(defColors, color);
  }
  else if ((color != ID_QUEDA)||(color != ID_BRANCO)) {
      makeTurn(defColors, color);
  }
}

void leaveIntersec(ColorConf &defColors[], int idCor) {
  moveUntilNotColor(defColors, idCor);
  trackPosControll(defColors, idCor);
  route(defColors);
}

void make180(ColorConf &defColors[], int idCor){
  turn(DIREITA, 180);
  leaveIntersec(defColors, idCor);
}

void makeTurn(ColorConf &defColors[], int idCor) {
  centerOnIntersec();
  if (idCor == dir.left) {
    turn(ESQUERDA, ANGLE90);
    leaveIntersec(defColors, idCor);
  } else if (idCor == dir.right) {
      turn(DIREITA, ANGLE90);
      leaveIntersec(defColors, idCor);
  } else if (idCor == dir.front) {
    leaveIntersec(defColors, idCor);
  } else {
    if (dir.right != -1) {
      if (dir.front != -1) {
        turn(ESQUERDA, ANGLE90);
        turnCount = 3;
      } else {
        turnCount = 2;
      }
    } else {
      turn(DIREITA, ANGLE90);
      turnCount = 1;
    }
    leaveIntersec(defColors, idCor);
  }
}
