/*
  Arquivo: route.nxc
  Descricao: Este programa cotem toda a logica de
    programacao do percorrimento de percurso
  Autores: Renato Nobre, Valesca Soares
  Data de Modificacao: 14/10/2018
  Versao: 0.3
*/

#include "include/route.h"

int lastColor = ID_PRETO;
int lastDir = 1;
int lastKnowColor = ID_BRANCO;

int lastFallDir = -1;


int turnCount = 0;
int turnVec[3][3] = {{UNKNOWNDIR, UNKNOWNDIR, UNKNOWNDIR},
                     {UNKNOWNDIR, UNKNOWNDIR, UNKNOWNDIR},
                     {UNKNOWNDIR, UNKNOWNDIR, UNKNOWNDIR}};

Directions dir;

//       D  F  E
// COR1 [2  2  1]
// COR2 [2  0  2]
// COR3 [0  0  2]
// 0 = DESCONHECIDO
// 1 = CERTO
// 2 = ERRADO


void recenter(ColorConf &defColors[]){
  int leftRead, rightRead;
  PlayTone(880, 500);
  leftRead = leftSensorColor(defColors);
  rightRead = rightSensorColor(defColors);
  if ((leftRead == ID_QUEDA) && (rightRead == ID_QUEDA)) {
    Off(MOTOR_BOTH);
  } else if (leftRead == ID_QUEDA) {
    Wait(50);
    while (leftRead != ID_BRANCO) {
      OnRev(MOTOR_RIGHT, 40);
      leftRead = leftSensorColor(defColors);
      if(leftRead == ID_ERRO) {
        leftRead = ID_QUEDA;
      }
    }
    Off(MOTOR_BOTH);
    /* turn(DIREITA, 10); */
  } else if (rightRead == ID_QUEDA){
    Wait(50);
    while (rightRead != ID_BRANCO) {
      OnRev(MOTOR_LEFT, 40);
      rightRead = rightSensorColor(defColors);
      if(rightRead == ID_ERRO) {
        rightRead = ID_QUEDA;
      }
    }
    Off(MOTOR_BOTH);
    /* turn(ESQUERDA, 10); */
  }
}

int avoidFall(ColorConf &defColors[], int leftColor, int rightColor){
  if ((leftColor == ID_QUEDA) ||
      (rightColor == ID_QUEDA)){
    Off(MOTOR_BOTH);
    recenter(defColors);
    Off(MOTOR_BOTH);
    return TRUE;
  }
  return FALSE;
}

int isConf(int cor) {
  for(int i = 0; i < 3; i ++) {
    if (turnVec[cor][i] == 1){
      return TRUE;
    }
  }
  return FALSE;
}

void adjustPosition(ColorConf &defColors[], int idColor, int leftColor, int rightColor) {
  if(idColor==ID_VERMELHO || idColor==ID_AZUL || idColor==ID_VERDE || idColor==ID_PRETO){
    Off(MOTOR_BOTH);

    string c1, c2;
    c1 = getColorName(leftColor);
    c2 = getColorName(rightColor);
    TextOut(0,LCD_LINE1,c1);
    TextOut(0,LCD_LINE2,c2);
    if (leftColor == idColor){
      while(rightColor != idColor) {
        OnFwd(MOTOR_RIGHT, 60);
        rightColor = rightSensorColor(defColors);
      }
    } else if (rightColor == idColor){
      while(leftColor != idColor) {
        OnFwd(MOTOR_LEFT, 60);
        leftColor = leftSensorColor(defColors);
      }
    }
    Off(MOTOR_BOTH);
  }
}

int trackPosControll(ColorConf &defColors[], int idColor) {
  int leftColor, rightColor;
  leftColor = leftSensorColor(defColors);
  rightColor = rightSensorColor(defColors);
  if (leftColor == ID_ERRO) {
    leftColor = lastKnowColor;
  }
  if (rightColor == ID_ERRO) {
    rightColor = lastKnowColor;
  }
  if (avoidFall(defColors, leftColor, rightColor) == FALSE){
    if (leftColor != idColor){
      if (leftColor != ID_ERRO) {
        adjustPosition(defColors, leftColor, leftColor, rightColor);
      }
    } else if (rightColor != idColor) {
      if (rightColor != ID_ERRO) {
        adjustPosition(defColors, rightColor, leftColor, rightColor);
      }
    }
    if (rightColor == ID_ERRO) {
      rightColor = lastKnowColor;
    }
    if(leftColor == ID_ERRO){
      leftColor = lastKnowColor;
    } else {
      lastKnowColor = leftColor;
    }
    return leftColor;
  } else {
    return ID_QUEDA;
  }
}


void startProperPID() {
  if (lastFallDir == ESQUERDA) {
    start fowardPIDPullLeft;
  } else if (lastFallDir == DIREITA) {
    start fowardPIDPullRight;
  } else {
    start fowardPID;
  }
}

void stopProperPID() {
  if (lastFallDir == ESQUERDA) {
    stop fowardPID;
  } else if (lastFallDir == DIREITA) {
    stop fowardPID;
  } else {
    stop fowardPID;
  }
}

void moveUntilWhite(ColorConf &defColors[], int idCor) {
  int leftColor, rightColor;
  leftColor = leftSensorColor(defColors);
  rightColor = rightSensorColor(defColors);

  startProperPID();
  /* start fowardPID; */

  while ((leftColor == idCor) ||
       (rightColor == idCor)) {
   leftColor = leftSensorColor(defColors);
   rightColor = rightSensorColor(defColors);
   if (leftColor == ID_ERRO) {
     leftColor = idCor;
   }
   if (rightColor == ID_ERRO) {
     rightColor = idCor;
   }
  }

  /* stop fowardPID; */
  stopProperPID();


  Off(MOTOR_BOTH);
}

void moveUntilNotColor(ColorConf &defColors[], int idCor) {
  int leftColor, rightColor;
  leftColor = leftSensorColor(defColors);
  rightColor = rightSensorColor(defColors);

  /* start fowardPID; */
  startProperPID();
  while ((leftColor == idCor) &&
         (rightColor == idCor)) {
   leftColor = leftSensorColor(defColors);
   rightColor = rightSensorColor(defColors);
   if (leftColor == ID_ERRO) {
     leftColor = idCor;
   }
   if (rightColor == ID_ERRO) {
     rightColor = idCor;
   }
  }
  /* stop fowardPID; */
  stopProperPID();
  Off(MOTOR_BOTH);
}

void centerOnIntersec() {
  byte x = BatteryState();
  x = abs(x-4);
  fowardCm(16+x);
}

void startRoute(ColorConf &defColors[]) {
  if (checkFileExistence(ROUTE_FILE_NAME, ROUTE_FILE_SIZE) == 1) {
    openForRead(ROUTE_FILE_NAME, ROUTE_FILE_SIZE);
    readDirectionOnFile(dir);
    dirToMat();
    closeFile();
  } else {
    initEmptyDir(dir);
    saveConfToFile();
  }
  Wait(50);
  PlayTone(220, 500);
  Wait(500);
  PlayTone(440, 500);
  Wait(500);
  while(true) {
    route(defColors);
  }
}

void route(ColorConf &defColors[]) {
  int color;

  int leftColor, rightColor;
  string colorNameL, colorNameR;

  moveUntilNotColor(defColors, ID_BRANCO);
  color = trackPosControll(defColors, ID_BRANCO);
  if (color == ID_PRETO) {
      if (isRamp() == TRUE) {
        foundRamp();
      } else {
        make180(defColors, color);
      }
  } else if ((color != ID_QUEDA)&&(color != ID_BRANCO)) {
    makeTurn(defColors, color);
  }
}

int isRamp() {
  for(int i = 0; i < 3; i++) {
    for(int j = 0; j < 3; j ++) {
      if (turnVec[i][j] == UNKNOWNDIR) {
        return FALSE;
      }
    }
  }
  return TRUE;
}

void foundRamp() {
  PlayTone(500, 500);
  Wait(1000);
  PlayTone(500, 500);
  Wait(1000);
  PlayTone(500, 500);
}

void leaveIntersec(ColorConf &defColors[], int idCor) {
  moveUntilWhite(defColors, idCor);
  trackPosControll(defColors, idCor);
  route(defColors);
}

void make180(ColorConf &defColors[], int idCor){
  int i = 0;

  lastDir = 1;

  if (lastColor == COLOR_ONE) {
    while (turnVec[0][i] == ERRORDIR) {
      i++;
      lastDir += 1;
    }
    turnVec[0][i] = ERRORDIR;
  } else if (lastColor == COLOR_TWO) {
    while (turnVec[1][i] == ERRORDIR) {
      i++;
      lastDir += 1;
    }
    turnVec[1][i] = ERRORDIR;
  } else if (lastColor == COLOR_THREE) {
    while (turnVec[2][i] == ERRORDIR) {
      i++;
      lastDir += 1;
    }
    turnVec[2][i] = ERRORDIR;
  }
  lastColor = ID_PRETO;
  turnCount = 1;
  saveConfToFile();
  turn(DIREITA, 180);
  leaveIntersec(defColors, idCor);
}

void recordDir() {
  int cont = 0;
  if ((lastColor == COLOR_ONE)&&(isConf(0) != TRUE)) { //
    PlayTone(500, 500);
    while(turnVec[0][cont] == ERRORDIR) {
      cont++;
    }
    turnVec[0][0] = ERRORDIR;
    turnVec[0][1] = ERRORDIR;
    turnVec[0][2] = ERRORDIR;
    turnVec[0][cont] = RIGHTDIR;
    turnVec[1][cont] = ERRORDIR;
    turnVec[2][cont] = ERRORDIR;
  } else if ((lastColor == COLOR_TWO)&&(isConf(1) != TRUE)) { //
    PlayTone(500, 500);
    while(turnVec[1][cont] == ERRORDIR) {
      cont++;
    }
    turnVec[1][0] = ERRORDIR;
    turnVec[1][1] = ERRORDIR;
    turnVec[1][2] = ERRORDIR;
    turnVec[1][cont] = RIGHTDIR;
    turnVec[0][cont] = ERRORDIR;
    turnVec[2][cont] = ERRORDIR;
  } else if ((lastColor == COLOR_THREE)&&(isConf(2) != TRUE)) { //
    PlayTone(500, 500);
    while(turnVec[2][cont] == ERRORDIR) {
      cont++;
    }
    turnVec[2][0] = ERRORDIR;
    turnVec[2][1] = ERRORDIR;
    turnVec[2][2] = ERRORDIR;
    turnVec[2][cont] = RIGHTDIR;
    turnVec[0][cont] = ERRORDIR;
    turnVec[1][cont] = ERRORDIR;
  }
  saveConfToFile();
}

void contTurn(int cont) {
  if (cont == 0) {
    Wait(50);
    turn(DIREITA, ANGLE90);
  } else if (cont == 1) {
    Wait(50);
  } else if (cont == 2) {
    Wait(50);
    turn(ESQUERDA, ANGLE90);
  }
}

void makeTurn(ColorConf &defColors[], int idCor) {
  centerOnIntersec();
  if (idCor == DIR_UNKNOWN) {
    return;
  }

  if (idCor == COLOR_ONE) {
    if (lastColor != ID_PRETO) {
      recordDir();
    }
    lastColor = COLOR_ONE;
    int cont = 0;
    if (turnCount == 0) {
      while(turnVec[0][cont] == ERRORDIR) {
        cont++;
      }
      contTurn(cont);
    } else {
      turnCount = 0;
      if (lastDir == 2) {
        Wait(50);
        turn(DIREITA, ANGLE90);
      } else if (turnVec[0][1] != ERRORDIR){
        Wait(50);
        turn(DIREITA, ANGLE90);
      }
    }
  } else if (idCor == COLOR_TWO) {
    if (lastColor != ID_PRETO) {
      recordDir();
    }
    lastColor = COLOR_TWO;
    int cont = 0;
    if (turnCount == 0) {
      while(turnVec[1][cont] == ERRORDIR) {
        cont++;
      }
      contTurn(cont);
    } else {
      turnCount = 0;
      if (lastDir == 2) {
        Wait(50);
        turn(DIREITA, ANGLE90);
      } else if (turnVec[1][1] != ERRORDIR){
        Wait(50);
        turn(DIREITA, ANGLE90);
      }
    }
  } else if (idCor == COLOR_THREE) {
    if (lastColor != ID_PRETO) {
      recordDir();
    }
    lastColor = COLOR_THREE;
    int cont = 0;
    if (turnCount == 0) {
      while(turnVec[2][cont] == ERRORDIR) {
        cont++;
      }
      contTurn(cont);
    } else {
      turnCount = 0;
      if (lastDir == 2) {
        Wait(50);
        turn(DIREITA, ANGLE90);
      } else if (turnVec[2][1] != ERRORDIR){
        Wait(50);
        turn(DIREITA, ANGLE90);
      }
    }
  }
  leaveIntersec(defColors, idCor);
}

void dirToMat() {
  turnVec[0][0] = dir.v00;
  turnVec[0][1] = dir.v01;
  turnVec[0][2] = dir.v02;
  turnVec[1][0] = dir.v10;
  turnVec[1][1] = dir.v11;
  turnVec[1][2] = dir.v12;
  turnVec[2][0] = dir.v20;
  turnVec[2][1] = dir.v21;
  turnVec[2][2] = dir.v22;
}

void matToDir() {
  dir.v00 = turnVec[0][0];
  dir.v01 = turnVec[0][1];
  dir.v02 = turnVec[0][2];
  dir.v10 = turnVec[1][0];
  dir.v11 = turnVec[1][1];
  dir.v12 = turnVec[1][2];
  dir.v20 = turnVec[2][0];
  dir.v21 = turnVec[2][1];
  dir.v22 = turnVec[2][2];
}

void saveConfToFile() {
  deleteFile(ROUTE_FILE_NAME, ROUTE_FILE_SIZE);
  openForWrite(ROUTE_FILE_NAME, ROUTE_FILE_SIZE);
  matToDir();
  writeDirectionOnFile(dir);
  closeFile();
}
