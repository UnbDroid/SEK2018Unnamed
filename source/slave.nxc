//SLAVE

/* Algumas coisas sobre comunicação
Para o escravo:
1 - Para o escravo enviar strings para o mestre utiliza-se a função SendResponseString(byte queue, string str);
byte queue: caixa onde a mensagem vai ser armazenada para envio (pode-se colocar de 0 a 9), eu defini uma constante OUTBOX
string str: a string que deseja enviar, pode-se colocar uma variável ou a mensagem diretamente entre parênteses
2 - Para o escravo enviar números para o mestre utiliza-se a função SendResponseNumber(byte queue, long val);
byte queue: caixa onde a mensagem vai ser armazenada para envio (pode-se colocar de 0 a 9), eu defini uma constante OUTBOX
long val: o número que deseja enviar, pode-se colocar uma variável ou o número direto
3 - Para o escravo receber números do mestre, utiliza-se a função ReceiveRemoteNumber(byte queue, bool clear, long &val);
byte queue: caixa de entrada onde a mensagem vai ser recebida (deve ser o mesmo número da caixa que foi mandada)
bool clear: true or false , caso seja true a cada mensagem nova que ele receber ele apaga a anterior, se for false ele guarda somente a primeira mensagem que receber
long &val: variável onde ele vai guardar o número recebido
4 - Para o escravo receber strings do mestre, utiliza-se a função ReceiveRemoteString(byte queue, bool clear, string &str);
byte queue: caixa de entrada onde a mensagem vai ser recebida (deve ser o mesmo número da caixa que foi mandada)
bool clear: true or false , caso seja true a cada mensagem nova que ele receber ele apaga a anterior, se for false ele guarda somente a primeira mensagem que receber
string &str: variavel onde ele vai guardar a string recebida
5 - Existe uma condição STAT_MSG_EMPTY_MAILBOX que serve para constatar que não existe novas mensagens recebidas
6 - Condição NO_ERR constata que não houve erro, igual no mestre

 */

#define BT_CONN 1
#define OUTBOX1 1
#define OUTBOX2 2
#define OUTBOX3 3
#define INBOX1 4
#define INBOX2 5
#define INBOX3 6
#define DIST_SIDE 30
#define DIST_FRONT1 40
#define DIST_FRONT2 40
#define VECTOR_SIZE 7

#include "include/defines.h"

/* Função que checa a conexão bluetooth entre os cérebros */
sub BTCheck(int conn){
  if (!BluetoothStatus(conn)==NO_ERR){
    TextOut(5,LCD_LINE2,"Sem conexão.");
    Wait(1000);
    Stop(true);
  }
}

void medianaOrder(int &v[], int sizeVector) {
   int i,j,aux,K;

   for(i=0;i<sizeVector-1;i++){

      for(j=0;j<sizeVector-1;j++){
         if(v[j]>v[j+1]){
            aux=v[j];
            v[j]=v[j+1];
            v[j+1]=aux;

         }
      }
   }
}


int medianaFilter(int &vetor[], int sizeVector){

   medianaOrder(vetor,sizeVector);

   return vetor[(sizeVector-1)/2];

}

task main(){
  string in1;
  int leftFront, rightFront, sideLeft, sideRight;
  int s_rightVector[VECTOR_SIZE], s_leftVector[VECTOR_SIZE], f_rightVector[VECTOR_SIZE], f_leftVector[VECTOR_SIZE], f_rightDistFiltered, f_leftDistFiltered, s_rightDistFiltered, s_leftDistFiltered, i;
  BTCheck(0); //checa a conexão com o mestre

  TextOut(10,LCD_LINE6,"Fdir:");
  TextOut(10,LCD_LINE4,"Fesq:");
  TextOut(50,LCD_LINE6,"Sdir:");
  TextOut(50,LCD_LINE4,"Sesq:");

  SetSensorLowspeed(FRONT_ULTRA_LEFT);
  SetSensorLowspeed(FRONT_ULTRA_RIGHT);
  SetSensorLowspeed(SIDE_ULTRA_LEFT);
  SetSensorLowspeed(SIDE_ULTRA_RIGHT);

  while(ReceiveRemoteString(INBOX1, true, in1) == STAT_MSG_EMPTY_MAILBOX);

  while(true) {
    string out3, in3, out2;
    /* Setando o sensor ultrassônico */
    SetSensorLowspeed(FRONT_ULTRA_LEFT);
    SetSensorLowspeed(FRONT_ULTRA_RIGHT);
    SetSensorLowspeed(SIDE_ULTRA_LEFT);
    SetSensorLowspeed(SIDE_ULTRA_RIGHT);

    leftFront = SensorUS(FRONT_ULTRA_LEFT);
    rightFront = SensorUS(FRONT_ULTRA_RIGHT);
    sideLeft = SensorUS(SIDE_ULTRA_LEFT);
    sideRight = SensorUS(SIDE_ULTRA_RIGHT);

    for(i=0;i<VECTOR_SIZE;i++){

	 		leftFront = SensorUS(FRONT_ULTRA_LEFT);
	 		rightFront = SensorUS(FRONT_ULTRA_RIGHT);
      sideLeft = SensorUS(SIDE_ULTRA_LEFT);
      sideRight = SensorUS(SIDE_ULTRA_RIGHT);

	 		f_leftVector[i] = leftFront;
	 		f_rightVector[i] = rightFront;
      s_leftVector[i] = sideLeft;
	 		s_rightVector[i] = sideRight;

	 	}

	 	f_leftDistFiltered = medianaFilter(f_leftVector,VECTOR_SIZE);
	 	f_rightDistFiltered = medianaFilter(f_rightVector,VECTOR_SIZE);
    s_leftDistFiltered = medianaFilter(s_leftVector,VECTOR_SIZE);
	 	s_rightDistFiltered = medianaFilter(s_rightVector,VECTOR_SIZE);


    /* Printando o número mandado na tela */
    NumOut(10,LCD_LINE5,f_leftDistFiltered);
    NumOut(10,LCD_LINE7,f_rightDistFiltered);
    NumOut(50,LCD_LINE5,s_leftDistFiltered);
    NumOut(50,LCD_LINE7,s_rightDistFiltered);

    Wait(500);
    ClearLine(LCD_LINE5);
    ClearLine(LCD_LINE7);

    /* Manda mensagem pro mestre */
    /* if(sideLeft<23 && sideRight<23){
        out4 = "fimRampa";
        SendResponseString(OUTBOX4,out4);
   } else if(rightFront<30 && leftFront<30){
     out4 = "Rampa";
     SendResponseString(OUTBOX, out4);
   } else if(sideRight<23){
     out4 = "turnRight";
     SendRespondeString(OUTBOX4, out4);
   } else */

    if (s_leftDistFiltered < DIST_SIDE) {
      out3 = "turnLeft";
      SendResponseString(OUTBOX3,out3);
      while(ReceiveRemoteString(INBOX3, true, in3) == STAT_MSG_EMPTY_MAILBOX);
      while(out2!="Find") {
        for(i=0;i<VECTOR_SIZE;i++){

    	 		leftFront = SensorUS(FRONT_ULTRA_LEFT);
    	 		rightFront = SensorUS(FRONT_ULTRA_RIGHT);

    	 		f_leftVector[i] = leftFront;
    	 		f_rightVector[i] = rightFront;

    	 	}

    	 	f_leftDistFiltered = medianaFilter(f_leftVector,VECTOR_SIZE);
    	 	f_rightDistFiltered = medianaFilter(f_rightVector,VECTOR_SIZE);
        if(f_rightDistFiltered < DIST_FRONT1){
          out2 = "Find";
          SendResponseString(OUTBOX2, out2);
        }
      }
    }


    /* Manda os valores lidos nos ultrassons pro mestre */



     /* SendResponseNumber(OUTBOX2,rightFront);
     SendResponseNumber(OUTBOX3,sideLeft);
     SendResponseNumber(OUTBOX4,sideRight);
     Wait(100); */

   }
}
