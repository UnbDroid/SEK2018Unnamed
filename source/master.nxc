//MASTER

/* Algumas coisas sobre comunicação
Para o mestre:
1 - Para o mestre enviar strings para o escravo utiliza-se a função SendRemoteString(byte conn, byte queue, string str);
byte conn: checa a comunicação, utiliza-se BT_CONN
byte queue: caixa onde a mensagem vai ser armazenada para envio (pode-se colocar de 0 a 9), eu defini uma constante OUTBOX
string str: a string que deseja enviar, pode-se colocar uma variável ou a mensagem diretamente entre parênteses
2 - Para o mestre enviar números para o escravo utiliza-se a função SendRemoteNumber(byte conn, byte queue, long val);
byte conn: checa a comunicação, utiliza-se BT_CONN
byte queue: caixa onde a mensagem vai ser armazenada para envio (pode-se colocar de 0 a 9), eu defini uma constante OUTBOX
long val: o número que deseja enviar, pode-se colocar uma variável ou o número direto
3 - Para o mestre receber números do escravo, utiliza-se a função ReceiveRemoteNumber(byte queue, bool clear, long &val);
byte queue: caixa de entrada onde a mensagem vai ser recebida (deve ser o mesmo número da caixa que foi mandada)
bool clear: true or false , caso seja true a cada mensagem nova que ele receber ele apaga a anterior, se for false ele guarda somente a primeira mensagem que receber
long &val: variável onde ele vai guardar o número recebido
4 - Para o mestre receber strings do escravo, utiliza-se a função ReceiveRemoteString(byte queue, bool clear, string &str);
byte queue: caixa de entrada onde a mensagem vai ser recebida (deve ser o mesmo número da caixa que foi mandada)
bool clear: true or false , caso seja true a cada mensagem nova que ele receber ele apaga a anterior, se for false ele guarda somente a primeira mensagem que receber
string &str: variavel onde ele vai guardar a string recebida
5 - Ao receber uma mensagem é necessário utilizar: if((função de receber) == NO_ERR); que checa só recebe mensagens sem erro
*/

#define BT_CONN 1
#define OUTBOX5 5
#define INBOX1 1
#define INBOX2 2
#define INBOX3 3
#define INBOX4 4
#define D_BONECO 22



  #include "lib/main.nxc"

/* Função que checa a conexão bluetooth entre os cérebros */

sub BTCheck(int conn){
  if (!BluetoothStatus(conn)==NO_ERR){
  TextOut(5,LCD_LINE2,"Sem conexão.");
  Wait(1000);
  Stop(true);
  }
}

/* Função para alinhar o boneco com a garra, recebe os valores recebidos pelo escravo.
   Lembrando que na platarforma costuma ter dois bonecos*/

void alinhar_boneco () {

  int ufront_esq, ufront_dir;

  while(ReceiveRemoteNumber(INBOX2, true,ufront_dir) == NO_ERR && ufront_dir > D_BONECO) {
    NumOut(10,LCD_LINE6,ufront_dir);
    OnFwd(MOTOR_RIGHT, 40);
    Off(MOTOR_RIGHT);
  }



  while(ReceiveRemoteNumber(INBOX3, true,ufront_esq) == NO_ERR && ufront_esq > D_BONECO){
    NumOut(10,LCD_LINE4,ufront_esq);
    OnFwd(MOTOR_LEFT, 40);
    Off(MOTOR_LEFT);
  }




}

/* Função que desce a garra que ja vai estar aberta, vai pra frente, pega o boneco e armazena no robô
   Garra termina aberta.
 */

int capturar() {



  alinhar_boneco ();

  while(1);

  //abaixar a garra
  RotateMotor(OUT_A, -70, 1000);
  RotateMotor(OUT_A, 70, 6000);

  //RotateMotor(OUT_A, -70, 4500);

  Off(GARRA);


  //(função para dar ré)

  return 1;

}


task main(){

  int nbonecos=0;

  string out5 = "Inicio";
  int ufront_esq, ufront_dir, uside_esq, uside_dir;
  BTCheck(BT_CONN); // checa a conexão com o escravo

  TextOut(10,LCD_LINE5,"Recebido:");
  /* TextOut(10,LCD_LINE3,"Fesq:");
  TextOut(50,LCD_LINE5,"Sdir:");
  TextOut(50,LCD_LINE3,"Sesq:"); */

  SendRemoteString(BT_CONN, OUTBOX5, out5);
while (true) {
  string in4, out;

  start fowardPID;
  /* Se a mensagem mandada pelo escravo não tiver erro, ele recebe a mensagem
   e printa o valor recebido na tela */

  /* if(ReceiveRemoteNumber(INBOX1, true,ufront_esq) == NO_ERR){
    NumOut(10,LCD_LINE4,ufront_esq);
  }
  if(ReceiveRemoteNumber(INBOX2, true,ufront_dir) == NO_ERR) {
    NumOut(10,LCD_LINE6,ufront_dir);
  }
  Wait(100); // Sem esse wait ele só recebe os 2 primeiros valores */
  /* if(ReceiveRemoteNumber(INBOX3, true,uside_dir) == NO_ERR) {
    NumOut(50,LCD_LINE4,uside_dir);
  } */

  /* Se os sensores laterais receberem um valor menor que
  a const "d_boneco"(distância máxima que o boneco pode ficar - em torno de 22cm),
  ele vira 90 graus na direção do boneco, captura-o, armazena e volta pra pista. */


  while(ReceiveRemoteString(INBOX4, true, in4) != NO_ERR); //mensagem recebida do escravo

  TextOut(0,LCD_LINE1,in4); //ver o que o mestre recebeu

  if(in4 == "turnLeft") {
    stop fowardPID;
    RemotePlayTone(BT_CONN, 500, 100);
    Off(MOTOR_BOTH);
    turn(ESQUERDA, 90);

    nbonecos += capturar();

    turn(DIREITA, 90);
    out = "Fim";
    SendRemoteString(BT_CONN, true, out);
  }
  /* else if(in4 == "turnRight"){

  }else if(in4 == "Rampa"){

  } */


  ClearLine(LCD_LINE1);

}

}
