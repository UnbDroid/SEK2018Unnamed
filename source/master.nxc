//MASTER

/* Algumas coisas sobre comunicação
Para o mestre:
1 - Para o mestre enviar strings para o escravo utiliza-se a função SendRemoteString(byte conn, byte queue, string str);
byte conn: checa a comunicação, utiliza-se BT_CONN
byte queue: caixa onde a mensagem vai ser armazenada para envio (pode-se colocar de 0 a 9), eu defini uma constante OUTBOX
string str: a string que deseja enviar, pode-se colocar uma variável ou a mensagem diretamente entre parênteses
2 - Para o mestre enviar números para o escravo utiliza-se a função SendRemoteNumber(byte conn, byte queue, long val);
byte conn: checa a comunicação, utiliza-se BT_CONN
byte queue: caixa onde a mensagem vai ser armazenada para envio (pode-se colocar de 0 a 9), eu defini uma constante OUTBOX
long val: o número que deseja enviar, pode-se colocar uma variável ou o número direto
3 - Para o mestre receber números do escravo, utiliza-se a função ReceiveRemoteNumber(byte queue, bool clear, long &val);
byte queue: caixa de entrada onde a mensagem vai ser recebida (deve ser o mesmo número da caixa que foi mandada)
bool clear: true or false , caso seja true a cada mensagem nova que ele receber ele apaga a anterior, se for false ele guarda somente a primeira mensagem que receber
long &val: variável onde ele vai guardar o número recebido
4 - Para o mestre receber strings do escravo, utiliza-se a função ReceiveRemoteString(byte queue, bool clear, string &str);
byte queue: caixa de entrada onde a mensagem vai ser recebida (deve ser o mesmo número da caixa que foi mandada)
bool clear: true or false , caso seja true a cada mensagem nova que ele receber ele apaga a anterior, se for false ele guarda somente a primeira mensagem que receber
string &str: variavel onde ele vai guardar a string recebida
5 - Ao receber uma mensagem é necessário utilizar: if((função de receber) == NO_ERR); que checa só recebe mensagens sem erro
*/

#define BT_CONN 1
#define INBOX1 1
#define INBOX2 2
#define INBOX3 3
#define OUTBOX1 4
#define OUTBOX2 5
#define OUTBOX3 6
#define OUTBOX4 7
#define D_BONECO_LADO 22
#define D_BONECO_FRENTE 40



  #include "lib/main.nxc"

/* Função que checa a conexão bluetooth entre os cérebros */
sub BTCheck(int conn){
  if (!BluetoothStatus(conn)==NO_ERR){
  TextOut(5,LCD_LINE2,"Sem conexão.");
  Wait(1000);
  Stop(true);
  }
}

void turnRightPID_garra(int distancia){
  int esq, dir,lRotation1, lRotation2;
  string in2 = "notFind";
  if (ReceiveRemoteNumber(INBOX1, true, dir) == NO_ERR); //valor ultrassom frente da direita
  //if (ReceiveRemoteNumber(INBOX2, true, esq) == NO_ERR); //valor ultrassom frente da esquerda
  ResetRotationCount(MOTOR_BOTH);
  PlayTone(220, 200);
  Wait(10);

  float lRotation = MotorRotationCount(MOTOR_LEFT);
  float rRotation = MotorRotationCount(MOTOR_RIGHT);
  float error, turn, pwrLeft, pwrRight, derivate;
  float integral = 0.0;
  float lastError = 0.0;

  while(in2!="Find"){
    if (ReceiveRemoteNumber(INBOX1, true, dir) == NO_ERR);
    lRotation = MotorRotationCount(MOTOR_LEFT);
    rRotation = MotorRotationCount(MOTOR_RIGHT);
    error = abs(lRotation) - abs(rRotation);
    integral += error;
    if (integral > 100) {
      integral = 100;
    } else if (integral < -100) {
      integral = -100;
    }
    derivate = error - lastError;
    turn = (KP * error) + (KI*integral) + (KD*derivate);
    pwrLeft = TP - turn;
    pwrRight = TP + turn;

    OnFwd(MOTOR_LEFT, pwrLeft);
    OnRev(MOTOR_RIGHT, pwrRight);
    lastError = error;
    if(ReceiveRemoteString(INBOX2, true, in2) == NO_ERR);
    if(in2 == "Find")
      Off(MOTOR_BOTH);
  }
}

void turnLeftPID_garra(int distancia) {
  int esq, dir,lRotation1, lRotation2;
  string in2 = "notFind";
  //valor ultrassom frente da direita
  //if (ReceiveRemoteNumber(INBOX2, true, esq) == NO_ERR); //valor ultrassom frente da esquerda

  ResetRotationCount(MOTOR_BOTH);
  Wait(500);
  PlayTone(220, 200);
  Wait(100);

  float lRotation = MotorRotationCount(MOTOR_LEFT);
  float rRotation = MotorRotationCount(MOTOR_RIGHT);
  float error, turn, pwrLeft, pwrRight, derivate;
  float integral = 0.0;
  float lastError = 0.0;
  while(in2!="Find"){
    lRotation = MotorRotationCount(MOTOR_LEFT);
    rRotation = MotorRotationCount(MOTOR_RIGHT);
    error = abs(lRotation) - abs(rRotation);
    integral += error;
    if (integral > 100) {
      integral = 100;
    } else if (integral < -100) {
      integral = -100;
    }
    derivate = error - lastError;
    turn = (KP * error) + (KI*integral) + (KD*derivate);
    pwrLeft = TP - turn;
    pwrRight = TP + turn;

    OnRev(MOTOR_LEFT, pwrLeft);
    OnFwd(MOTOR_RIGHT, pwrRight);
    lastError = error;
    if(ReceiveRemoteString(INBOX2, true, in2) == NO_ERR);
    if(in2 == "Find")
      Off(MOTOR_BOTH);
  }
}

   /* Função para alinhar o boneco com a garra, recebe os valores recebidos pelo escravo.
      Lembrando que na platarforma costuma ter dois bonecos*/
void alignToy(int direcao){
  if (direcao == ESQUERDA) {
    turnLeftPID_garra(D_BONECO_FRENTE);
  } /*else if (direcao == DIREITA) {
      turnRightPID_garra(D_BONECO_FRENTE);
      }*/
 }



/* Função que desce a garra que ja vai estar aberta, vai pra frente, pega o boneco e armazena no robô
   Garra termina aberta.
 */

int catchToy() {
  string out3 = "Manda";
  /* string out1 = "Achei"; */

  SendRemoteString(BT_CONN, OUTBOX3, out3);
  alignToy(ESQUERDA);
  /* SendRemoteString(BT_CONN, OUTBOX6, out1); */

 while(1);


   //abaixar a garra
  RotateMotor(GARRA, -70, 1000);
  RotateMotor(GARRA, 70, 6000);
  //RotateMotor(OUT_A, -70, 4500);
  Off(GARRA);
  //(função para dar ré)
  return 1;
 }

task main(){

  int nbonecos=0;

  string out1 = "Inicio";
  BTCheck(BT_CONN); // checa a conexão com o escravo

  SendRemoteString(BT_CONN, OUTBOX1, out1);
  while (true) {
   string in3;

   start fowardPID;

   while(ReceiveRemoteString(INBOX3, true, in3) != NO_ERR); //mensagem recebida do escravo

     //ver o que o mestre recebeu

   if(in3 == "turnLeft") {
     stop fowardPID;
     Off(MOTOR_BOTH);

     nbonecos += catchToy();


   }
   /* else if(in4 == "turnRight"){

   }else if(in4 == "Rampa"){

   } */


   ClearLine(LCD_LINE1);
 }
}
