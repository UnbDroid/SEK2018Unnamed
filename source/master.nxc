//MASTER

/* Algumas coisas sobre comunicação
Para o mestre:
1 - Para o mestre enviar strings para o escravo utiliza-se a função SendRemoteString(byte conn, byte queue, string str);
byte conn: checa a comunicação, utiliza-se BT_CONN
byte queue: caixa onde a mensagem vai ser armazenada para envio (pode-se colocar de 0 a 9), eu defini uma constante OUTBOX
string str: a string que deseja enviar, pode-se colocar uma variável ou a mensagem diretamente entre parênteses
2 - Para o mestre enviar números para o escravo utiliza-se a função SendRemoteNumber(byte conn, byte queue, long val);
byte conn: checa a comunicação, utiliza-se BT_CONN
byte queue: caixa onde a mensagem vai ser armazenada para envio (pode-se colocar de 0 a 9), eu defini uma constante OUTBOX
long val: o número que deseja enviar, pode-se colocar uma variável ou o número direto
3 - Para o mestre receber números do escravo, utiliza-se a função ReceiveRemoteNumber(byte queue, bool clear, long &val);
byte queue: caixa de entrada onde a mensagem vai ser recebida (deve ser o mesmo número da caixa que foi mandada)
bool clear: true or false , caso seja true a cada mensagem nova que ele receber ele apaga a anterior, se for false ele guarda somente a primeira mensagem que receber
long &val: variável onde ele vai guardar o número recebido
4 - Para o mestre receber strings do escravo, utiliza-se a função ReceiveRemoteString(byte queue, bool clear, string &str);
byte queue: caixa de entrada onde a mensagem vai ser recebida (deve ser o mesmo número da caixa que foi mandada)
bool clear: true or false , caso seja true a cada mensagem nova que ele receber ele apaga a anterior, se for false ele guarda somente a primeira mensagem que receber
string &str: variavel onde ele vai guardar a string recebida
5 - Ao receber uma mensagem é necessário utilizar: if((função de receber) == NO_ERR); que checa só recebe mensagens sem erro
*/

#define BT_CONN 1
#define OUTBOX5 5
#define OUTBOX4 4
#define OUTBOX6 6
#define INBOX1 1
#define INBOX2 2
#define INBOX3 3
#define INBOX4 4
#define D_BONECO_LADO 22
#define D_BONECO_FRENTE 40



  #include "lib/main.nxc"

/* Função que checa a conexão bluetooth entre os cérebros */

sub BTCheck(int conn){
  if (!BluetoothStatus(conn)==NO_ERR){
  TextOut(5,LCD_LINE2,"Sem conexão.");
  Wait(1000);
  Stop(true);
  }
}



void turnRightPID_garra(int distancia){
  int esq, dir;
  ReceiveRemoteNumber(INBOX2, true, dir); //valor ultrassom frente da direita
  ReceiveRemoteNumber(INBOX3, true, esq); //valor ultrassom frente da esquerda

  ResetRotationCount(MOTOR_BOTH);
  Wait(10);

  float lRotation = MotorRotationCount(MOTOR_LEFT);
  float rRotation = MotorRotationCount(MOTOR_RIGHT);
  float error, turn, pwrLeft, pwrRight, derivate;
  float integral = 0.0;
  float lastError = 0.0;

  while(esq > distancia){

    lRotation = MotorRotationCount(MOTOR_LEFT);
    rRotation = MotorRotationCount(MOTOR_RIGHT);
    error = abs(lRotation) - abs(rRotation);
    integral = ((2/3)*integral) + error;
    derivate = error - lastError;
    turn = (KP * error) + (KI*integral) + (KD*derivate);
    pwrLeft = TP - turn;
    pwrRight = TP + turn;

    OnFwd(MOTOR_LEFT, pwrLeft);
    OnRev(MOTOR_RIGHT, pwrRight);
    lastError = error;
  }
  Off(MOTOR_BOTH);
}

   void turnLeftPID_garra(int distancia) {
     int esq, dir;
     ReceiveRemoteNumber(INBOX2, true, dir); //valor ultrassom frente da direita
     //ReceiveRemoteNumber(INBOX3, true, esq); //valor ultrassom frente da esquerda

     ResetRotationCount(MOTOR_BOTH);
     Wait(10);

     float lRotation = MotorRotationCount(MOTOR_LEFT);
     float rRotation = MotorRotationCount(MOTOR_RIGHT);
     float error, turn, pwrLeft, pwrRight, derivate;
     float integral = 0.0;
     float lastError = 0.0;
     while(dir > distancia){
       ReceiveRemoteNumber(INBOX2, true, dir);
       lRotation = MotorRotationCount(MOTOR_LEFT);
       rRotation = MotorRotationCount(MOTOR_RIGHT);
       error = abs(lRotation) - abs(rRotation);
       integral = ((2/3)*integral) + error;
       derivate = error - lastError;
       turn = (KP * error) + (KI*integral) + (KD*derivate);
       pwrLeft = TP - turn;
       pwrRight = TP + turn;

       OnRev(MOTOR_LEFT, pwrLeft);
       OnFwd(MOTOR_RIGHT, pwrRight);
       lastError = error;
     }
     Off(MOTOR_BOTH);
   }

   /* Função para alinhar o boneco com a garra, recebe os valores recebidos pelo escravo.
      Lembrando que na platarforma costuma ter dois bonecos*/

void alinhar_boneco(int direcao){
  if (direcao == ESQUERDA) {
    turnLeftPID_garra(D_BONECO_FRENTE);
  } /*else if (direcao == DIREITA) {
    turnRightPID_garra(D_BONECO_FRENTE);
  }*/
}



/* Função que desce a garra que ja vai estar aberta, vai pra frente, pega o boneco e armazena no robô
   Garra termina aberta.
 */

int capturar() {
string out = "Manda";
string out1 = "Achei";

  SendRemoteString(BT_CONN, OUTBOX6, out);

  alinhar_boneco (ESQUERDA);

  SendRemoteString(BT_CONN, OUTBOX6, out1);

  while(1);


  //abaixar a garra
  RotateMotor(GARRA, -70, 1000);
  RotateMotor(GARRA, 70, 6000);

  //RotateMotor(OUT_A, -70, 4500);

  Off(GARRA);



  //(função para dar ré)

  return 1;

}


task main(){

  int nbonecos=0;

  string out5 = "Inicio";
  int ufront_esq, ufront_dir, uside_esq, uside_dir;
  BTCheck(BT_CONN); // checa a conexão com o escravo


  SendRemoteString(BT_CONN, OUTBOX5, out5);
while (true) {
  string in4, out;

  start fowardPID;
  /* Se a mensagem mandada pelo escravo não tiver erro, ele recebe a mensagem
   e printa o valor recebido na tela */

  /* if(ReceiveRemoteNumber(INBOX1, true,ufront_esq) == NO_ERR){
    NumOut(10,LCD_LINE4,ufront_esq);
  }
  if(ReceiveRemoteNumber(INBOX2, true,ufront_dir) == NO_ERR) {
    NumOut(10,LCD_LINE6,ufront_dir);
  }
  Wait(100); // Sem esse wait ele só recebe os 2 primeiros valores */
  /* if(ReceiveRemoteNumber(INBOX3, true,uside_dir) == NO_ERR) {
    NumOut(50,LCD_LINE4,uside_dir);
  } */

  /* Se os sensores laterais receberem um valor menor que
  a const "d_boneco"(distância máxima que o boneco pode ficar - em torno de 22cm),
  ele vira 90 graus na direção do boneco, captura-o, armazena e volta pra pista. */


  while(ReceiveRemoteString(INBOX4, true, in4) != NO_ERR); //mensagem recebida do escravo

  TextOut(0,LCD_LINE1,in4); //ver o que o mestre recebeu

  if(in4 == "turnLeft") {
    stop fowardPID;
    Off(MOTOR_BOTH);

    nbonecos += capturar();

    turn(DIREITA, 90);
    out = "Fim";
    SendRemoteString(BT_CONN, OUTBOX4, out);
  }
  /* else if(in4 == "turnRight"){

  }else if(in4 == "Rampa"){

  } */


  ClearLine(LCD_LINE1);

}

}
